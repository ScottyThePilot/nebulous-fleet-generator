use std::fmt;
use std::str::FromStr;

use std::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Not};



macro_rules! try_opt {
  ($expr:expr) => (if let Some(__v) = $expr { __v } else { return None });
}

type KeyBytes = [u8; 16];

/// Within the fleet files, a few fields are 22-character-long alphanumeric strings.
/// These are actually 16 bytes (128 bits) encoded as Base64 (particularly URL-safe Base64).
///
/// This struct represents those Base64 strings.
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Key {
  inner: KeyBytes
}

impl Key {
  /// After testing a very large number of keys from fleet files generated by the game,
  /// a few bits in the decoded bytes appear to always be left as 0's for some reason.
  ///
  /// This has 0's set at those bits, and 1's elsewhere.
  ///
  /// You can use [`Key::is_masked`] to test if a key matches this mask.
  pub const MASK: Self = key!("_________0-__________w");

  pub const fn is_masked(self) -> bool {
    const INV_MASK: Key = Key::MASK.not();
    self.and(INV_MASK).to_u128() == 0
  }

  #[inline]
  pub const fn mask(self) -> Self {
    self.and(Self::MASK)
  }

  pub const fn to_bytes(self) -> KeyBytes {
    self.inner
  }

  pub fn to_str(self, buf: &mut [u8; 22]) -> &str {
    let mut key = u128::from_be_bytes(self.inner);
    buf[21] = encode_byte((key & 0b11 << 4) as u8);
    key >>= 2;

    for slot in buf[..21].iter_mut().rev() {
      *slot = encode_byte((key & 0b111111) as u8);
      key >>= 6;
    };

    std::str::from_utf8(buf).unwrap()
  }

  pub const fn from_bytes(bytes: KeyBytes) -> Self {
    Self { inner: bytes }
  }

  pub const fn from_str_unchecked(s: &str) -> Self {
    match Self::from_str(s) {
      Some(key) => key,
      None => panic!("failed to decode key")
    }
  }

  pub const fn from_str(s: &str) -> Option<Self> {
    let s = s.as_bytes();
    if s.len() != 22 { return None };
    let (&last_ch, mut s) = try_opt!(s.split_last());
    if !matches!(last_ch, b'A' | b'Q' | b'g' | b'w') { return None };
    let last_value = try_opt!(decode_byte(last_ch));

    let mut inner = 0u128;
    while let Some((&ch, rest)) = s.split_first() {
      let value = try_opt!(decode_byte(ch));
      inner <<= 6;
      inner |= value as u128;
      s = rest;
    };

    inner <<= 2;
    inner |= (last_value >> 4) as u128;

    Some(Key {
      inner: inner.to_be_bytes()
    })
  }

  #[inline]
  pub const fn or(self, other: Self) -> Self {
    Self::from_u128(self.to_u128() | other.to_u128())
  }

  #[inline]
  pub const fn and(self, other: Self) -> Self {
    Self::from_u128(self.to_u128() & other.to_u128())
  }

  #[inline]
  pub const fn xor(self, other: Self) -> Self {
    Self::from_u128(self.to_u128() ^ other.to_u128())
  }

  #[inline]
  pub const fn not(self) -> Self {
    Self::from_u128(!self.to_u128())
  }

  #[inline]
  const fn to_u128(self) -> u128 {
    u128::from_ne_bytes(self.inner)
  }

  #[inline]
  const fn from_u128(num: u128) -> Self {
    Self { inner: u128::to_ne_bytes(num) }
  }
}

impl fmt::Debug for Key {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    let value = u128::from_ne_bytes(self.inner);
    write!(f, "Key({value:032x})")
  }
}

impl fmt::Display for Key {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    let mut buf = [0; 22];
    let s = self.to_str(&mut buf);
    f.write_str(s)?;
    Ok(())
  }
}

impl FromStr for Key {
  type Err = KeyFromStrError;

  fn from_str(s: &str) -> Result<Self, Self::Err> {
    Key::from_str(s).ok_or(KeyFromStrError)
  }
}

#[derive(Debug, Error, Clone, Copy)]
#[error("failed to decode key")]
pub struct KeyFromStrError;

xml::impl_deserialize_nodes_parse!(Key);
xml::impl_serialize_nodes_display!(Key);

macro_rules! impl_bit_binop {
  ($Trait:ident, $function:ident, $TraitAssign:ident, $function_assign:ident, $base:ident) => {
    impl $Trait for Key {
      type Output = Key;

      fn $function(self, rhs: Self) -> Self::Output {
        self.$base(rhs)
      }
    }

    impl $TraitAssign for Key {
      fn $function_assign(&mut self, rhs: Self) {
        *self = self.$base(rhs);
      }
    }
  };
}

impl_bit_binop!(BitAnd, bitand, BitAndAssign, bitand_assign, and);
impl_bit_binop!(BitOr, bitor, BitOrAssign, bitor_assign, or);
impl_bit_binop!(BitXor, bitxor, BitXorAssign, bitxor_assign, xor);

impl Not for Key {
  type Output = Key;

  fn not(self) -> Self::Output {
    self.not()
  }
}



const fn encode_byte(ch: u8) -> u8 {
  b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"[ch as usize]
}

const fn decode_byte(ch: u8) -> Option<u8> {
  match ch {
    b'A'..=b'Z' => Some((ch - b'A') + 0),
    b'a'..=b'z' => Some((ch - b'a') + 26),
    b'0'..=b'9' => Some((ch - b'0') + 52),
    b'-' => Some(62),
    b'_' => Some(63),
    _ => None
  }
}
